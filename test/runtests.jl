using ExamplePackage
using Test
using LinearAlgebra

@testset "ExamplePackage.jl" begin
    @test printDocstrDict(LinearAlgebra, :eigen) == IdDict{Any, Any}(Union{Tuple{TB}, Tuple{TA}, Tuple{AbstractMatrix{TA}, AbstractMatrix{TB}}} where {TA, TB} => Base.Docs.DocStr(svec("    eigen(A, B) -> GeneralizedEigen\n\nComputes the generalized eigenvalue decomposition of `A` and `B`, returning a\n[`GeneralizedEigen`](@ref) factorization object `F` which contains the generalized eigenvalues in\n`F.values` and the generalized eigenvectors in the columns of the matrix `F.vectors`.\n(The `k`th generalized eigenvector can be obtained from the slice `F.vectors[:, k]`.)\n\nIterating the decomposition produces the components `F.values` and `F.vectors`.\n\nAny keyword arguments passed to `eigen` are passed through to the lower-level\n[`eigen!`](@ref) function.\n\n# Examples\n```jldoctest\njulia> A = [1 0; 0 -1]\n2×2 Matrix{Int64}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Matrix{Int64}:\n 0  1\n 1  0\n\njulia> F = eigen(A, B);\n\njulia> F.values\n2-element Vector{ComplexF64}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\njulia> F.vectors\n2×2 Matrix{ComplexF64}:\n  0.0+1.0im   0.0-1.0im\n -1.0+0.0im  -1.0-0.0im\n\njulia> vals, vecs = F; # destructuring via iteration\n\njulia> vals == F.values && vecs == F.vectors\ntrue\n```\n"), nothing, Dict{Symbol, Any}(:typesig => Union{Tuple{TB}, Tuple{TA}, Tuple{AbstractMatrix{TA}, AbstractMatrix{TB}}} where {TA, TB}, :module => LinearAlgebra, :linenumber => 456, :binding => LinearAlgebra.eigen, :path => "/buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/eigen.jl")), Tuple{Union{Hermitian{T, S}, Hermitian{Complex{T}, S}, Symmetric{T, S}} where {T<:Real, S}, UnitRange} => Base.Docs.DocStr(svec("    eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> Eigen\n\nComputes the eigenvalue decomposition of `A`, returning an [`Eigen`](@ref) factorization object `F`\nwhich contains the eigenvalues in `F.values` and the eigenvectors in the columns of the\nmatrix `F.vectors`. (The `k`th eigenvector can be obtained from the slice `F.vectors[:, k]`.)\n\nIterating the decomposition produces the components `F.values` and `F.vectors`.\n\nThe following functions are available for `Eigen` objects: [`inv`](@ref), [`det`](@ref), and [`isposdef`](@ref).\n\nThe [`UnitRange`](@ref) `irange` specifies indices of the sorted eigenvalues to search for.\n\n!!! note\n    If `irange` is not `1:n`, where `n` is the dimension of `A`, then the returned factorization\n    will be a *truncated* factorization.\n"), nothing, Dict{Symbol, Any}(:typesig => Tuple{Union{Hermitian{T, S}, Hermitian{Complex{T}, S}, Symmetric{T, S}} where {T<:Real, S}, UnitRange}, :module => LinearAlgebra, :linenumber => 685, :binding => LinearAlgebra.eigen, :path => "/buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/symmetric.jl")), Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T => Base.Docs.DocStr(svec("    eigen(A; permute::Bool=true, scale::Bool=true, sortby) -> Eigen\n\nComputes the eigenvalue decomposition of `A`, returning an [`Eigen`](@ref) factorization object `F`\nwhich contains the eigenvalues in `F.values` and the eigenvectors in the columns of the\nmatrix `F.vectors`. (The `k`th eigenvector can be obtained from the slice `F.vectors[:, k]`.)\n\nIterating the decomposition produces the components `F.values` and `F.vectors`.\n\nThe following functions are available for `Eigen` objects: [`inv`](@ref), [`det`](@ref), and [`isposdef`](@ref).\n\nFor general nonsymmetric matrices it is possible to specify how the matrix is balanced\nbefore the eigenvector calculation. The option `permute=true` permutes the matrix to become\ncloser to upper triangular, and `scale=true` scales the matrix by its diagonal elements to\nmake rows and columns more equal in norm. The default is `true` for both options.\n\nBy default, the eigenvalues and vectors are sorted lexicographically by `(real(λ),imag(λ))`.\nA different comparison function `by(λ)` can be passed to `sortby`, or you can pass\n`sortby=nothing` to leave the eigenvalues in an arbitrary order.   Some special matrix types\n(e.g. [`Diagonal`](@ref) or [`SymTridiagonal`](@ref)) may implement their own sorting convention and not\naccept a `sortby` keyword.\n\n# Examples\n```jldoctest\njulia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\nEigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nvalues:\n3-element Vector{Float64}:\n  1.0\n  3.0\n 18.0\nvectors:\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> F.values\n3-element Vector{Float64}:\n  1.0\n  3.0\n 18.0\n\njulia> F.vectors\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> vals, vecs = F; # destructuring via iteration\n\njulia> vals == F.values && vecs == F.vectors\ntrue\n```\n"), nothing, Dict{Symbol, Any}(:typesig => Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T, :module => LinearAlgebra, :linenumber => 179, :binding => LinearAlgebra.eigen, :path => "/buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/eigen.jl")), Tuple{Union{Hermitian{T, S}, Hermitian{Complex{T}, S}, Symmetric{T, S}} where {T<:Real, S}, Real, Real} => Base.Docs.DocStr(svec("    eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> Eigen\n\nComputes the eigenvalue decomposition of `A`, returning an [`Eigen`](@ref) factorization object `F`\nwhich contains the eigenvalues in `F.values` and the eigenvectors in the columns of the\nmatrix `F.vectors`. (The `k`th eigenvector can be obtained from the slice `F.vectors[:, k]`.)\n\nIterating the decomposition produces the components `F.values` and `F.vectors`.\n\nThe following functions are available for `Eigen` objects: [`inv`](@ref), [`det`](@ref), and [`isposdef`](@ref).\n\n`vl` is the lower bound of the window of eigenvalues to search for, and `vu` is the upper bound.\n\n!!! note\n    If [`vl`, `vu`] does not contain all eigenvalues of `A`, then the returned factorization\n    will be a *truncated* factorization.\n"), nothing, Dict{Symbol, Any}(:typesig => Tuple{Union{Hermitian{T, S}, Hermitian{Complex{T}, S}, Symmetric{T, S}} where {T<:Real, S}, Real, Real}, :module => LinearAlgebra, :linenumber => 711, :binding => LinearAlgebra.eigen, :path => "/buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/symmetric.jl")))
    @test printDocstrDict(LinearAlgebra, :triu) == IdDict{Any, Any}(Tuple{AbstractMatrix{T} where T, Integer} => Base.Docs.DocStr(svec("    triu(M, k::Integer)\n\nReturns the upper triangle of `M` starting from the `k`th superdiagonal.\n\n# Examples\n```jldoctest\njulia> a = fill(1.0, (4,4))\n4×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> triu(a,3)\n4×4 Matrix{Float64}:\n 0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\njulia> triu(a,-3)\n4×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n```\n"), nothing, Dict{Symbol, Any}(:typesig => Tuple{AbstractMatrix{T} where T, Integer}, :module => LinearAlgebra, :linenumber => 367, :binding => LinearAlgebra.triu, :path => "/buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl")), Tuple{AbstractMatrix{T} where T} => Base.Docs.DocStr(svec("    triu(M)\n\nUpper triangle of a matrix.\n\n# Examples\n```jldoctest\njulia> a = fill(1.0, (4,4))\n4×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> triu(a)\n4×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 0.0  1.0  1.0  1.0\n 0.0  0.0  1.0  1.0\n 0.0  0.0  0.0  1.0\n```\n"), nothing, Dict{Symbol, Any}(:typesig => Tuple{AbstractMatrix{T} where T}, :module => LinearAlgebra, :linenumber => 319, :binding => LinearAlgebra.triu, :path => "/buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl")))
end
